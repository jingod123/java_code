package edu.type;

public class Ex01 {
	
	public static void main(String[] args) {
		//자료형
		//primitive(기본형) : 기본 데이터(숫자1개, 문자1개, 논리데이터 1개) 저장 변수
		//reference(참조형) : 객체나 배열같은 복합 데이터 저장 변수 (값 자체가 아닌 참조값(주소값) 을 저장)
		
		//컴퓨터가 다루는 데이터의 크기 : 기본(byte)
		//bit < byte < KB < MB < GB < TB < PB(페타바이트) < EB(엑사) < ZB(제타) < YB(요타)
		//1bit : 가장 작은 데이터 단위 0 또는 1을 가질 수 있음
		//1byte : 8bit 00001010(2) -> 10(10)
		//1KB : 1,024 byte (1,000으로 생각하는 경우도 있음)  (2^10)
		//1MB : 1,024 KB (2^20)
		
		//기본형(Primitive Type) : 8가지 기본 데이터 타입 (고정, 추가 가능성 x)
		//1)논리형 : 1byte/1bit(0 or 1 / true or false / 참 or 거짓)
		boolean isEmpty = true; //비어있으면 true / 채워져있으면 false
		boolean hasPermission = false; //권한이 있으면 true / 권한이 없으면 false
		
		//2)문자형 : 2byte , 문자 하나 저장 , 문자는 '' 으로 표현
		char grade = 'A';
		//char grade1 = 'AB'; 두개 이상의 문자 저장 표현 불가능
		char initial = '강';
		//char name = '강예진';
		
		//두개 이상의 문자를 저장하지 못하기 때문에 문자(문자열) 표현 불가능
		//=> 배열 구조나 직접 연결하는 구조를 사용해서 문자열을 표현할 수는 있음 (매우 복잡) => C언어에서는 이런 형식을 사용하고 있음
		//=> 자바에서는 일반적으로 String 이라는 형식을 쓰고 있음 (Reference 타입)
		
		//**사실 문자형(char)는 정수형으로 구분하고 있음
		// : 코드상으로는 문자를 저장하지만 내부적으로는 정수값(유니코드값)으로 처리되기 때문
		// 영문, 기본 특수문자 등은 아스키 코드 참고!
		// A : 65
		// B : 66
		// a : 97
		// b : 98
		char alphaA = 65; //빨간줄이 없다는 건 문법상 가능하다 라는것!
		//자바 출력문 (콘솔창에 출력) , 'syso' + ctrl + space, ctrl + F11 로 실행
		System.out.println(alphaA);   //A출력
		System.out.println(alphaA + 1); //66출력 (1은 정수형이기 때문에 정수 연산 결과가 출력됨)
		System.out.println((char)(alphaA + 1)); //66이 B의 유니코드이기 때문에 char형으로 형변환
		
		// 한글등은 유니코드 참고! 강 -> U+AC15  (전세계 문자를 표현할 수 있는 코드라서 형식이 복잡함)
		char unicode = '\uAC15';
		System.out.println(unicode);
		
		//3)정수형 : 4개 자료형이 있음 (각각 표현할 수 있는 정수 범위가 다름)
		// : 상황에 따라 필요한 데이터의 크기와 범위에 맞는 정수형을 제공하기 위함 => 메모리 크기, 성능 고려
		//-1. byte : (1바이트) -128 ~ 127 , 메모리 절약이 중요한 경우 사용
		//00000000(2)->0   11111111(2)-> -1
		//01111111(2)->127 10000000(2)-> -128 => -128 ~ 127
		byte byteNum = 1;
		//byte byteNum2 = 300;  해결방법 2개 확인하기
		
		//long 보고 다시 설명할거
		//1 -> int(4)
		//byteNum -> byte(1)
		//큰데이터를 작은공간에 넣으려고함 -> 불가능
		//but, 1은 byte로 표현가능한 숫자
		//byte byteNum = (byte)1; -> 원래는 이렇게 써야댐 (위에 chat 형변환이랑 같음)
		//어짜피 byte 범위에 포함되는 값이라서 컴파일러가 자동으로 처리해주는 것!
		
		//-2. short : (2바이트)-32,768 ~ 32,767 , 바이트보다는 더 큰 숫자가 필요하지만 int보다는 작은 범위가 필요할 경우
		short shortNum = 30000;
		//short shortNum = (short)30000;
		
		//-3. **int (정수형의 기본형) : (4바이트), -2,147,483,648 ~ 2,147,483,647 , 가장 일반적으로 사용됨
		int intNum = 100000000;
		
		//-4. long : (8바이트), -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
		//           큰 파일 크기, 시간(밀리초 단위) 등을 계산
		//long longNum = 100000000000;-> 팀문제
		//대입연산자 -> 무조건 오른쪽만 먼저 보기
		//정수는 int가 무조건 기본형! 100000000000 이 숫자 자체가 int 형으로 표현이 불가능함
		//byte 부터 다시 설명 필요함!
		
		//long longNum = 100000000000;
		//long longNum1 = (long)100000000000; //int를 long으로 바꾸겠다는 의미(형변환)인데 애초에 int 형으로 표현 자체가 안됨
		//난 저숫자를 표현할 수 있는 long형으로 쓰겠다고!!!!!!! => 명시적으로 지정
		long longNum = 100000000000l;  //처음부터 long형(8바이트)으로 선언, 형변환이 아님!
		//l(L) -> long 타입 리터럴(고정값) 접미사 (해당값은 long 타입을 컴파일러에게 알려줌)
		int a = 10;  // 10은 정수 리터럴(값)
		char b = 'A';  //'A'는 문자 리터럴(값)

		
		long longNum2 = 10;
		//10 -> int(int형으로 표현가능)  => 나는 10을 long형 리터럴로 사용하고 싶어 => l을 붙여야함 => ? 안붙여도 문제없음
		//자동형변환 : int 타입에서 long 타입으로 자동으로 형변환이 일어남
		//? => long (8byte) > int (4byte) : int로 표현할 수 있는 값은 long 형으로 충분히 표현할 수 있음 
		// => 컴파일러가 자동으로 형변환해줌
		
		//* 형변환 (Type Conversion)
		//1. 자동형변환 (Implicit)
		//ex) long longNum = 10;  // 10은 int(4Byte) -> long(8Byte) 충분히 표현 가능하므로 자동으로 형변환 해줌
		//무조건 변수 데이터 타입 크기가 리터럴(값) 타입의 크기보다 커야함!
		
		byte bNum = 10; //10은 int, 문제, 자동형변환인가?
		//X , int(4Byte) / byte(1Byte) => 10은 byte로 표현가능한 숫자이기때문에 컴파일러가 허용해주는 것일뿐 자동형변환이라고 하지 않음
		short sNum = bNum; //자동형변환 O
		
		//2. 명시적형변환 (강제형변환) (Explicit)
		//ex1) char alphaA = 65;
		//    System.out.println((char)(alphaA + 1));
		//alphaA(65) + 1 => 정수
		//char는 유니코드를 사용하므로 정수는 문자형으로 쓸수 있음 int -> char 강제(명시적)형변환
		//(char) -> 캐스팅(Casting) : () 사용해서 형변환하는 것
		
		//ex2) 
		//byte b2 = (byte)10;  강제(명시적)형변환 int -> byte
		
		//정리할 시간
		//1. 프로젝트, 패키지, 클래스, 메서드 정의와 명명규칙
		//2. 변수명 규칙
		//3. 자료형 구분 (기본타입, 레퍼런스 타입)
		//4. 기본형 (논리, 문자, 정수)
		//5. 형변환 (자동, 명시(강제))
		
		//4)실수형(부동소수점) : 2개 자료형이 있음
		//부동소수점?
		//실수표현방식 : 고정소수점, 부동소수점
		//1. 고정소수점 : 부호 / 정수부 / 소수부 로 고정으로 나누어서 처리
		//   5.625(10) -> 101.101(2)
		//위 실수를 float(4Byte->32bit) 형으로 표현할 경우
		//1bit(부호) / 15bit(정수부) / 16bit(소수부)
		// 0 (부호)/ 000000000000101(정수부) / 0000000010100000(소수부)
		//=> 직관적이지만 표현 가능 범위가 매우 적음 (정수부가 크거나 소수부가 큰 경우도 있는데 다 표현하지 못할 수 있음)
		//=> * 최대 크기 자체가 고정이기때문에 소수부를 전부 표현하지 못할 가능성이 높기도 하고 반대로 공간이 낭비될 수도 있음
		
		//2. 부동소수점(floating-point) : 부호 / 지수부 / 가수부
		//float(4Byte -> 32bit)
		// 1bit(부호) / 23bit(가수부) / 8bit(지수부) 
		
		// 3.75(10) -> 11.11(2)
		// 1.111 * 2^1     / bias(편향->모든 지수를 양수로 표현하기 위해 사용, float는 지수부가 8비트라 -127 ~ 128(2의보수 사용하지 않음)
		//	                  float-127, double-1023) 1+127 = 128
		// 0 (부호) / 11100000000000000000000 (가수부) / 10000000 (지수부)
		
		//=> 표현 가능한 숫자의 범위가 넓음, 큰범위의 숫자를 효율적으로 처리할 수 있어 과학계산, 금융, 게임 등에서 사용가능함
		//=> but, 연산속도가 느림, 정밀도 손실(근사값)
		
		
		//-1. float : (4byte) 1/8/23  , ±1.4 × 10^(-45) ~ ±3.4 × 10^38
		//메모리를 효율적으로(최소화) 다뤄야 할 경우
		
		//float fNum = 3.14;  문제, 이 코드는 왜 문법적으로 틀렸을까?
		//실수형은 double이 기본값 3.14(double) -> float 로 형변환(자동형변환)이 안됨 => double의 크기가 더 큼(8byte)
		// => 강제형변환 혹은 3.14를 애초에 float형으로 쓸수 있도록 명시해(형변환x -> l 붙이는 것처럼) 줘야함
		float fNum1 = (float)3.14; //강제형변환
		float fNum2 = 3.14f; // float형 리터럴 접미사 (f/F) 3.14를 float 값으로 쓰겠다!
		
		//-2. double : (실수 기본형)(8byte)1/11/52  , ±5.0 × 10^(-324) ~ ±1.8 × 10^308
		//				=> double이 더 많은 실수를 표현할 수 있어 정밀함
		//정밀도가 중요한 계산, 큰수
		double dNum1 = 3.14;
		
		
		
		
		//ppt 강제 형변환 부분
		byte b3 = (byte)3000000;
		System.out.println(b3);  //표현불가능한 영역은 버려짐
	}
	
}
